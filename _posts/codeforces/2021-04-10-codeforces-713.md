---
layout: post
title: "Codeforces: Round #713 (Div.3)"
category: Codeforces
tags: [ì•Œê³ ë¦¬ì¦˜, Codeforces]
comments: true
mathjax: true
---

> Codeforces

# A. Spy Detected!

You are given an array $ğ‘$ consisting of $ğ‘›$ $(ğ‘›â‰¥3)$ positive integers. It is known that in this array, all the numbers except one are the same (for example, in the array $[4,11,4,4]$ all numbers except one are equal to $4$).

Print the index of the element that does not equal others. The numbers in the array are numbered from one.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤100)$. Then ğ‘¡ test cases follow.

The first line of each test case contains a single integer $ğ‘›$ $(3â‰¤ğ‘›â‰¤100)$ â€” the length of the array $ğ‘$.

The second line of each test case contains $ğ‘›$ integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ $(1â‰¤ğ‘ğ‘–â‰¤100)$.

It is guaranteed that all the numbers except one in the $ğ‘$ array are the same.

### Output
For each test case, output a single integer â€” the index of the element that is not equal to others.

## í’€ì´


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const char nl = '\n';

int A[101];

void solve() {
    int n; cin >> n;
    vector<int> v(n);
    memset(A, 0, sizeof(A));
    int k;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        A[v[i]]++;
    }
    for (int i = 1; i <= 100; i++) {
        if (A[i] > 1) k = i;
    }
    for (int i = 0; i < n; i++) {
        if (v[i] != k) {cout << i + 1 << nl; return; }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# B. Almost Rectangle

There is a square field of size $ğ‘›Ã—ğ‘›$ in which two cells are marked. These cells can be in the same row or column.

You are to mark two more cells so that they are the corners of a rectangle with sides parallel to the coordinate axes.

For example, if $ğ‘›=4$ and a rectangular field looks like this (there are asterisks in the marked cells):
```
. . * .
. . . .
* . . .
. . . .
```
Then you can mark two more cells as follows
```
* . * .
. . . .
* . * .
. . . .
```
If there are several possible solutions, then print any of them.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤400)$. Then $ğ‘¡$ test cases follow.

The first row of each test case contains a single integer $ğ‘›$ $(2â‰¤ğ‘›â‰¤400)$ â€” the number of rows and columns in the table.

The following $ğ‘›$ lines each contain ğ‘› characters `'.'` or `'*'` denoting empty and marked cells, respectively.

It is guaranteed that the sums of $ğ‘›$ for all test cases do not exceed $400$.

It is guaranteed that there are exactly two asterisks on the field. They can be in the same row/column.

It is guaranteed that the solution exists.

### Output
For each test case, output $ğ‘›$ rows of $ğ‘›$ characters â€” a field with four asterisks marked corresponding to the statements. If there multiple correct answers, print any of them.

## í’€ì´


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const char nl = '\n';

char A[401][401];

void solve() {
    int n; cin >> n;
    vector<int> y;
    vector<int> x;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> A[i][j];
            if (A[i][j] == '*') {
                y.push_back(i);
                x.push_back(j);
            }
        }
    }
    if (y[0] == y[1]) {
        if (y[0] == n - 1) {
            A[y[0] - 1][x[0]] = '*';
            A[y[0] - 1][x[1]] = '*';
        } else {
            A[y[0] + 1][x[0]] = '*';
            A[y[0] + 1][x[1]] = '*';
        }
    } else if (x[0] == x[1]) {
        if (x[0] == n - 1) {
            A[y[0]][x[0] - 1] = '*';
            A[y[1]][x[0] - 1] = '*';
        } else {
            A[y[0]][x[0] + 1] = '*';
            A[y[1]][x[0] + 1] = '*';
        }
    } else {
        A[y[0]][x[1]] = '*';
        A[y[1]][x[0]] = '*';
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << A[i][j];
        }
        cout << nl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# C. A-B Palindrome

You are given a string $ğ‘ $ consisting of the characters `'0'`, `'1'`, and `'?'`. You need to replace all the characters with `'?'` in the string ğ‘  by `'0'` or `'1'` so that the string becomes a palindrome and has exactly $ğ‘$ characters `'0'` and exactly ğ‘ characters `'1'`. Note that each of the characters `'?'` is replaced independently from the others.

A string $ğ‘¡$ of length $ğ‘›$ is called a palindrome if the equality $ğ‘¡[ğ‘–]=ğ‘¡[ğ‘›âˆ’ğ‘–+1]$ is true for all $ğ‘–$ $(1â‰¤ğ‘–â‰¤ğ‘›)$.

For example, if $ğ‘ =$`"01?????0"`, $ğ‘=4$ and $ğ‘=4$, then you can replace the characters '?' in the following ways:

* `"01011010";`
* `"01100110".`

For the given string $ğ‘ $ and the numbers $ğ‘$ and $ğ‘$, replace all the characters with `'?'` in the string $ğ‘ $ by `'0'` or `'1'` so that the string becomes a palindrome and has exactly $ğ‘$ characters `'0'` and exactly $ğ‘$ characters `'1'`.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤10^4)$. Then $ğ‘¡$ test cases follow.

The first line of each test case contains two integers $ğ‘$ and $ğ‘$ $(0â‰¤ğ‘,ğ‘â‰¤2â‹…10^5, ğ‘+ğ‘â‰¥1)$.

The second line of each test case contains the string $ğ‘ $ of length $ğ‘+ğ‘$, consisting of the characters `'0'`, `'1'`, and `'?'`.

It is guaranteed that the sum of the string lengths of $ğ‘ $ over all test cases does not exceed $2â‹…10^5$.

### Output
For each test case, output:

* `"-1"`, if you can't replace all the characters `'?'` in the string $ğ‘ $ by `'0'` or `'1'` so that the string becomes a palindrome and that it contains exactly ğ‘ characters `'0'` and exactly $ğ‘$ characters `'1'`;
* the string that is obtained as a result of the replacement, otherwise. 

If there are several suitable ways to replace characters, you can output any.

## í’€ì´


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const char nl = '\n';

char A[200001];

void solve() {
    int a, b; cin >> a >> b;
    int na = 0, nb = 0;
    for (int i = 0; i < a + b; i++) cin >> A[i];
    for (int i = 0; i < a + b; i++) {
        if (A[i] == '?' && A[a + b - 1 - i] != '?') A[i] = A[a + b - 1 - i];
    }
    for (int i = 0; i < a + b; i++) {
        if (A[i] == '0') na++;
        else if (A[i] == '1') nb++;
        if (A[i] != A[a + b - 1 - i]) {
            cout << "-1\n";
            return;
        }
    }
    if ((a + b) % 2 == 1) {
        if (A[(a + b) / 2] == '?') {
            if (a % 2 == 1) { A[(a + b) / 2] = '0'; na++; }
            else { A[(a + b) / 2] = '1'; nb++; }
        }

    }
    for (int i = 0; i < a + b; i++) {
        if (A[i] == '?') {
            if (na < a) {
                A[i] = '0';
                A[a + b - 1 - i] = '0';
                na += 2;
            } else {
                A[i] = '1';
                A[a + b - 1 - i] = '1';
                nb += 2;
            }
        }
    }
    if (na != a || nb != b) cout << "-1\n";
    else {
        for (int i = 0; i < a + b; i++) {
            cout << A[i] << " \n" [i == a + b - 1];
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# D. Corrupted Array

You are given a number $ğ‘›$ and an array $ğ‘_1,ğ‘_2,â€¦,ğ‘_{ğ‘›+2}$, obtained according to the following algorithm:

* some array $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ was guessed;
* array $ğ‘$ was written to array $ğ‘$, i.e. $ğ‘ğ‘–=ğ‘ğ‘–$ $(1â‰¤ğ‘–â‰¤ğ‘›)$;
* The $(ğ‘›+1)$-th element of the array $ğ‘$ is the sum of the numbers in the array $ğ‘$, i.e. $ğ‘_{ğ‘›+1}=ğ‘_1+ğ‘_2+â€¦+ğ‘_ğ‘›$;
* The $(ğ‘›+2)$-th element of the array ğ‘ was written some number $ğ‘¥$ $(1â‰¤ğ‘¥â‰¤10^9)$, i.e. $ğ‘_{ğ‘›+2}=ğ‘¥$;
* The array $ğ‘$ was shuffled. 

For example, the array $ğ‘=[2,3,7,12,2]$ it could be obtained in the following ways:

* $ğ‘=[2,2,3]$ and $ğ‘¥=12$;
* $ğ‘=[3,2,7]$ and $ğ‘¥=2$. 

For the given array $ğ‘$, find any array $ğ‘$ that could have been guessed initially.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤10^4)$. Then $ğ‘¡$ test cases follow.

The first line of each test case contains a single integer $ğ‘›$ $(1â‰¤ğ‘›â‰¤2â‹…10^5)$.

The second row of each test case contains $ğ‘›+2$ integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_{ğ‘›+2}$ $(1â‰¤ğ‘_ğ‘–â‰¤10^9)$.

It is guaranteed that the sum of $ğ‘›$ over all test cases does not exceed $2â‹…10^5$.

### Output
For each test case, output:

* `"-1"`, if the array $ğ‘$ could not be obtained from any array $ğ‘$;
* $ğ‘›$ integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$, otherwise. 

If there are several arrays of $ğ‘$, you can output any.

## í’€ì´


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const char nl = '\n';

void solve() {
    int n; cin >> n;
    vector<ll> B(n + 2);
    for (int i = 0; i < n + 2; i++) cin >> B[i];
    sort(B.begin(), B.end());
    if (n == 1) {
        if( B[0] == B[1] || B[0] == B[2]) cout << B[0] << nl;
        else if (B[1] == B[2]) cout << B[1] << nl;
        else cout << "-1" << nl;
        return;
    }
    ll sum = 0;
    for (int i = 0; i < n + 1; i++) sum += B[i];
    int idx = -1;
    for (int i = 0; i < n + 1; i++) {
        if (sum - B[i] == B[n] || sum - B[i] == B[n + 1]) { idx = i; break; }
    }
    if (idx == -1) { cout << "-1" << nl; return; }
    for (int i = 0; i < n + 1; i++) {
        if (i == idx) continue;
        cout << B[i] << " ";
    }
    cout << nl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}
```
<https://codeforces.com/contest/1512>{:target="_blank"}

---
layout: post
title: "Codeforces: Round #708 (Div.2)"
category: Codeforces
tags: [ì•Œê³ ë¦¬ì¦˜, Codeforces]
comments: true
mathjax: true
---

> Codeforces

# A. Meximization

You are given an integer $ğ‘›$ and an array $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$. You should reorder the elements of the array ğ‘ in such way that the sum of ğŒğ„ğ— on prefixes ($ğ‘–$-th prefix is $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘–$) is maximized.

Formally, you should find an array $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$, such that the sets of elements of arrays ğ‘ and ğ‘ are equal (it is equivalent to array ğ‘ can be found as an array ğ‘ with some reordering of its elements) and $\sum_{ğ‘–=1}^ğ‘› ğŒğ„ğ—(ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘–)$ is maximized.

$ğŒğ„ğ—$ of a set of nonnegative integers is the minimal nonnegative integer such that it is not in the set.

For example, $ğŒğ„ğ—({1,2,3})=0$, $ğŒğ„ğ—({0,1,2,4,5})=3$.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤100)$ â€” the number of test cases.

The first line of each test case contains a single integer $ğ‘›$ $(1â‰¤ğ‘›â‰¤100)$.

The second line of each test case contains $ğ‘›$ integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ $(0â‰¤ğ‘_ğ‘–â‰¤100)$.

### Output
For each test case print an array $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ â€” the optimal reordering of $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$, so the sum of $ğŒğ„ğ—$ on its prefixes is maximized.

If there exist multiple optimal answers you can find any.

## í’€ì´
0 ë¶€í„° 100 ê¹Œì§€ ë°°ì—´ì„ ë§Œë“  ë‹¤ìŒ ê° ìˆ«ìì— ë§ì¶° ê° ìˆ«ìê°€ ëª‡ê°œ ìˆëŠ”ì§€ ì„¸ì–´ì¤€ë‹¤. ì²˜ìŒì—” ìˆœì„œëŒ€ë¡œ 0 ë¶€í„° 100 ê¹Œì§€ ëŒë©´ì„œ ìˆ«ìê°€ ìˆìœ¼ë©´ ì¶œë ¥í•´ì£¼ê³  í•˜ë‚˜ì”© ë¹¼ì¤€ë‹¤. ì´í›„ì—” ë‚¨ì€ ìˆ«ì ì•„ë¬´ê±°ë‚˜ ì¶œë ¥í•´ë„ ë˜ë¯€ë¡œ ë‚¨ì€ ìˆœì„œëŒ€ë¡œ ë‹¤ ì¶œë ¥í•´ì¤€ë‹¤.

### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

int A[102];
int vst[102];

void solve() {
    int n; cin >> n;
    memset(vst, 0, sizeof(vst));
    for (int i = 0; i < n; i++) {
        cin >> A[i];
        vst[A[i]]++;
    }
    for (int i = 0; i < 101; i++) {
        if (vst[i] > 0) {
            cout << i << " ";
            vst[i]--;
        }
    }
    for (int i = 0; i < 101; i++) {
        while (vst[i] > 0) {
            cout << i << " ";
            vst[i]--;
        }
    }
    cout << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# B. M-arrays

You are given an array $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ consisting of $ğ‘›$ positive integers and a positive integer $ğ‘š$.

You should divide elements of this array into some arrays. You can order the elements in the new arrays as you want.

Let's call an array $ğ‘š$-divisible if for each two adjacent numbers in the array (two numbers on the positions $ğ‘–$ and $ğ‘–+1$ are called adjacent for each $ğ‘–$) their sum is divisible by $ğ‘š$. An array of one element is $ğ‘š$-divisible.

Find the smallest number of $ğ‘š$-divisible arrays that $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ is possible to divide into.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤1000)$ â€” the number of test cases.

The first line of each test case contains two integers $ğ‘›, ğ‘š$ $(1â‰¤ğ‘›â‰¤10^5,1â‰¤ğ‘šâ‰¤10^5)$.

The second line of each test case contains ğ‘›integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ $(1â‰¤ğ‘_ğ‘–â‰¤10^9)$.

It is guaranteed that the sum of $ğ‘›$ and the sum of $ğ‘š$ over all test cases do not exceed $10^5$.

### Output
For each test case print the answer to the problem.

## í’€ì´
m ì˜ ë‚˜ë¨¸ì§€ë¡œ ëœ ë°°ì—´ì„ ë§Œë“  ë‹¤ìŒ ê° ìˆ«ìì— ë§ì¶° A[i] % mì— ëŒ€í•´ ëª‡ ê°œ ìˆëŠ”ì§€ ì„¸ì–´ì¤€ë‹¤. ìˆ«ìê°€ mì´ë©´ í•˜ë‚˜ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì²˜ìŒì— ì„¸ì–´ì¤€ë‹¤. ì´í›„ 1 ë¶€í„° m ê¹Œì§€ ëë©´ì„œ B[i]ì™€ B[m - i]ì—ì„œ ë‘ ìˆ˜ê°€ ëª¨ë‘ 0ì´ ì•„ë‹ˆë¼ë©´ cntë¥¼ 1 ë”í•˜ì£¼ê³  ë‘ ìˆ˜ë¥¼ ë¹„êµí•˜ì—¬ ì‘ì€ ìˆ˜ëŠ” 0ìœ¼ë¡œ ë§Œë“¤ì–´ì£¼ê³  í°ìˆ˜ëŠ” ì‘ì€ìˆ˜ + 1 ë§Œí¼ ë¹¼ì¤€ë‹¤. ë‘ ìˆ˜ê°€ ê°™ë‹¤ë©´ ë‘˜ ë‹¤ 0 ìœ¼ë¡œ ë§Œë“¤ì–´ì¤€ë‹¤. ì´í›„ ë‚¨ì€ ìˆ«ìë“¤ì— ëŒ€í•´ cntë¥¼ ë”í•´ì¤€ë‹¤.

### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    int n, m; cin >> n >> m;
    vector<int> A(n);
    vector<int> B(m);
    for (int i = 0; i < n; i++) {
        cin >> A[i];
        B[A[i] % m]++;
    }
    if (m == 1) { cout << "1\n"; return; }
    int cnt = (B[0] == 0 ? 0 : 1);
    for (int i = 1; i < m; i++) {
        if (B[i] != 0 && B[m - i] != 0) {
            if (B[i] > B[m - i]) { B[i] -= B[m - i] + 1; B[m - i] = 0; }
            else if (B[i] < B[m - i]) { B[m - i] -= B[i] + 1; B[i] = 0; }
            else { B[i] = 0; B[m - i] = 0; }
            cnt++;
        }
    }
    for (int i = 1; i < m; i++) {
        while (B[i] > 0) {
            B[i]--;
            cnt++;
        }
    }
    cout << cnt << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# C1. k-LCM (easy version)

**It is the easy version of the problem. The only difference is that in this version $ğ‘˜=3$**.

You are given a positive integer $ğ‘›$. Find $ğ‘˜$ positive integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜$, such that:
* $ğ‘_1+ğ‘_2+â€¦+ğ‘_ğ‘˜=ğ‘›$
* $ğ¿ğ¶ğ‘€(ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜)â‰¤\frac{ğ‘›}{2}$

Here $ğ¿ğ¶ğ‘€$ is the [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of numbers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜$.

We can show that for given constraints the answer always exists.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤10^4)$ â€” the number of test cases.

The only line of each test case contains two integers $ğ‘›, ğ‘˜$ $(3â‰¤ğ‘›â‰¤10^9, ğ‘˜=3)$.

### Output
For each test case print $ğ‘˜$ positive integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜$, for which all conditions are satisfied.

## í’€ì´
ê·œì¹™ì„ ì°¾ì•„ì„œ í’€ì—ˆë‹¤.

* nì´ 4ì˜ ë°°ìˆ˜ì´ë©´ {$\frac{n}{2}, \frac{n}{4}, \frac{n}{4}$} ë¡œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.<br>
* nì´ 4ì˜ ë°°ìˆ˜ê°€ ì•„ë‹Œ ì§ìˆ˜ë©´ {$\frac{n}{2}-1, \frac{n}{2}-1, 2$} ë¡œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.<br>
* nì´ í™€ìˆ˜ì´ë©´ {$\frac{n}{2}, \frac{n}{2}, 1$} ë¡œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.

### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    int n, k; cin >> n >> k;
    if (n % 4 == 0) cout << n / 2 << " " << n / 4 << " " << n / 4 << "\n";
    else if (n % 2 == 0) cout << n / 2 - 1 << " " << n / 2 - 1 << " " << 2 << "\n";
    else cout << n / 2 << " " << n / 2 << " " << 1 << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# C2. k-LCM (hard version)

**It is the hard version of the problem. The only difference is that in this version $3â‰¤ğ‘˜â‰¤ğ‘›$**.

You are given a positive integer $ğ‘›$. Find $ğ‘˜$ positive integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜$, such that:
* $ğ‘_1+ğ‘_2+â€¦+ğ‘_ğ‘˜=ğ‘›$
* $ğ¿ğ¶ğ‘€(ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜)â‰¤\frac{ğ‘›}{2}$

Here $ğ¿ğ¶ğ‘€$ is the [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) of numbers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜$.

We can show that for given constraints the answer always exists.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤10^4)$ â€” the number of test cases.

The only line of each test case contains two integers $ğ‘›, ğ‘˜$ $(3â‰¤ğ‘›â‰¤10^9, 3â‰¤ğ‘˜â‰¤ğ‘›)$.

It is guaranteed that the sum of $ğ‘˜$ over all test cases does not exceed $10^5$.


### Output
For each test case print $ğ‘˜$ positive integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘˜$, for which all conditions are satisfied.

## í’€ì´
ìœ„ ê·œì¹™ì—ì„œ ì‘ìš©í•˜ë©´ ëœë‹¤.

ë¨¼ì € kê°€ 3ì´ ë ë•Œê¹Œì§€ 1ì„ ì¶œë ¥í•˜ë©´ì„œ nê³¼ kë¥¼ ì¤„ì—¬ì¤€ë‹¤.

ì´í›„ ìœ„ ê·œì¹™ê³¼ ê°™ì´ ì¶œë ¥í•˜ë©´ ëœë‹¤.

* nì´ 4ì˜ ë°°ìˆ˜ì´ë©´ {$\frac{n}{2}, \frac{n}{4}, \frac{n}{4}$} ë¡œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.<br>
* nì´ 4ì˜ ë°°ìˆ˜ê°€ ì•„ë‹Œ ì§ìˆ˜ë©´ {$\frac{n}{2}-1, \frac{n}{2}-1, 2$} ë¡œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.<br>
* nì´ í™€ìˆ˜ì´ë©´ {$\frac{n}{2}, \frac{n}{2}, 1$} ë¡œ êµ¬ì„±í•  ìˆ˜ ìˆë‹¤.

### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    int n, k; cin >> n >> k;
    while (k > 3) {
        n--; k--;
        cout << 1 << " ";
    }
    if (n % 4 == 0) cout << n / 2 << " " << n / 4 << " " << n / 4 << "\n";
    else if (n % 2 == 0) cout << n / 2 - 1 << " " << n / 2 - 1 << " " << 2 << "\n";
    else cout << n / 2 << " " << n / 2 << " " << 1 << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```
<https://codeforces.com/contest/1497>{:target="_blank"}

---
layout: post
title: "Codeforces: Round #710 (Div.3)"
category: Codeforces
tags: [ì•Œê³ ë¦¬ì¦˜, Codeforces]
comments: true
mathjax: true
---

> Codeforces

# A. Strange Table

Polycarp found a rectangular table consisting of $ğ‘›$ rows and $ğ‘š$ columns. He noticed that each cell of the table has its number, obtained by the following algorithm **"by columns"**:

 * cells are numbered starting from one;
 * cells are numbered from left to right by columns, and inside each column from top to bottom;
 * number of each cell is an integer one greater than in the previous cell. 

For example, if $ğ‘›=3$ and $ğ‘š=5$, the table will be numbered as follows:
```
1  4  7  10  13
2  5  8  11  14
3  6  9  12  15
```

However, Polycarp considers such numbering inconvenient. He likes the numbering **"by rows"**:

* cells are numbered starting from one;
* cells are numbered from top to bottom by rows, and inside each row from left to right;
* number of each cell is an integer one greater than the number of the previous cell. 

For example, if $ğ‘›=3$ and $ğ‘š=5$, then Polycarp likes the following table numbering:
```
 1   2   3   4   5
 6   7   8   9  10
11  12  13  14  15
```

Polycarp doesn't have much time, so he asks you to find out what would be the cell number in the numbering **"by rows"**, if in the numbering **"by columns"** the cell has the number $ğ‘¥$?

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤10^4)$. Then $ğ‘¡$ test cases follow.

Each test case consists of a single line containing three integers $ğ‘›, ğ‘š, ğ‘¥$ $(1â‰¤ğ‘›,ğ‘šâ‰¤10^6, 1â‰¤ğ‘¥â‰¤ğ‘›â‹…ğ‘š)$, where $ğ‘›$ and $ğ‘š$ are the number of rows and columns in the table, and $ğ‘¥$ is the cell number.

Note that the numbers in some test cases do not fit into the $32$-bit integer type, so you must use at least the $64$-bit integer type of your programming language.

### Output
For each test case, output the cell number in the numbering $"by rows"$.

## í’€ì´


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    ll n, m, x; cin >> n >> m >> x;
    ll div = (x - 1) / n, mod = (x - 1) % n;
    cout << m * mod + div + 1 << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# B. Partial Replacement

You are given a number $ğ‘˜$ and a string $ğ‘ $ of length $ğ‘›$, consisting of the characters `'.'` and `'*'`. You want to replace some of the `'*'` characters with `'x'` characters so that the following conditions are met:

* The first character `'*'` in the original string should be replaced with `'x'`;
* The last character `'*'` in the original string should be replaced with `'x'`;
* The distance between two neighboring replaced characters `'x'` must not exceed $ğ‘˜$ (more formally, if you replaced characters at positions $ğ‘–$ and $ğ‘—$ $(ğ‘–<ğ‘—)$ and at positions $[ğ‘–+1,ğ‘—âˆ’1]$ there is no `"x"` symbol, then $ğ‘—âˆ’ğ‘–$ must be no more than $ğ‘˜$). 

For example, if $ğ‘›=7$, $ğ‘ =$`.**.***` and $ğ‘˜=3$, then the following strings will satisfy the conditions above:

* `.xx.*xx;`
* `.x*.x*x;`
* `.xx.xxx.`

But, for example, the following strings will not meet the conditions:

* `.**.*xx` (the first character `'*'` should be replaced with `'x'`);
* `.x*.xx*` (the last character `'*'` should be replaced with `'x'`);
* `.x*.*xx` (the distance between characters at positions $2$ and $6$ is greater than $ğ‘˜=3$). 

Given $ğ‘›$, $ğ‘˜$, and $ğ‘ $, find the minimum number of `'*'` characters that must be replaced with `'x'` in order to meet the above conditions.

### Input
The first line contains one integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤500)$. Then $ğ‘¡$ test cases follow.

The first line of each test case contains two integers $ğ‘›$ and $ğ‘˜$ $(1â‰¤ğ‘˜â‰¤ğ‘›â‰¤50)$.

The second line of each test case contains a string $ğ‘ $ of length$ğ‘›$, consisting of the characters `'.'` and `'*'`.

It is guaranteed that there is at least one `'*'` in the string $ğ‘ $.

It is guaranteed that the distance between any two neighboring `'*'` characters does not exceed $ğ‘˜$.

### Output
For each test case output the minimum number of `'*'` characters that must be replaced with `'x'` characters in order to satisfy the conditions above.

## í’€ì´


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    int n, k; cin >> n >> k;
    string s; cin >> s;
    int begin = 0, end = 0;
    for (int i = 0; i < (int) s.size(); i++) {
        if (s[i] == '*') { begin = i; break; }
    }
    for (int i = (int) s.size(); i >= 0; i--) {
        if (s[i] == '*') { end = i; break; }
    }
    if (begin == end) { cout << "1\n"; return; }
    int cnt = 1;
    s[begin] = 'x';
    for (int i = 0; i < (int) s.size(); i++) {
        if (s[i] == 'x') {
            for (int j = k; j >= 1; j--) {
                if (i + j < (int) s.size() && s[i + j] == '*') {
                    s[i + j] = 'x';
                    cnt++;
                    i += j - 1;
                    break;
                }
            }
        }
    }
    if (s[end] == '*') cnt++;
    cout << cnt << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# C. Double-ended Strings

You are given the strings $ğ‘$ and $ğ‘$, consisting of lowercase Latin letters. You can do any number of the following operations in any order:

* if $\|ğ‘\|>0$ (the length of the string $ğ‘$ is greater than zero), delete the first character of the string $ğ‘$, that is, replace $ğ‘$ with $ğ‘_2ğ‘_3â€¦ğ‘_ğ‘›$;
* if $\|ğ‘\|>0$, delete the last character of the string $ğ‘$, that is, replace $ğ‘$ with $ğ‘_1ğ‘_2â€¦ğ‘_{ğ‘›âˆ’1}$;
* if $\|ğ‘\|>0$ (the length of the string $ğ‘$ is greater than zero), delete the first character of the string $ğ‘$, that is, replace $ğ‘$ with $ğ‘_2ğ‘_3â€¦ğ‘_ğ‘›$;
* if $\|ğ‘\|>0$, delete the last character of the string $ğ‘$, that is, replace $ğ‘$ with $ğ‘_1ğ‘_2â€¦ğ‘_{ğ‘›âˆ’1}$. 

Note that after each of the operations, the string $ğ‘$ or $ğ‘$ may become empty.

For example, if $ğ‘=$`"hello"` and $ğ‘=$`"icpc"`, then you can apply the following sequence of operations:

* delete the first character of the string $ğ‘$ â‡’ $ğ‘=$`"ello"` and $ğ‘=$`"icpc"`;
* delete the first character of the string $ğ‘$ â‡’ $ğ‘=$`"ello"` and $ğ‘=$`"cpc"`;
* delete the first character of the string $ğ‘$ â‡’ $ğ‘=$`"ello"` and $ğ‘=$`"pc"`;
* delete the last character of the string $ğ‘$ â‡’ $ğ‘=$`"ell"` and $ğ‘=$`"pc"`;
* delete the last character of the string $ğ‘$ â‡’ $ğ‘=$`"ell"` and $ğ‘=$`"p"`. 

For the given strings $ğ‘$ and $ğ‘$, find the minimum number of operations for which you can make the strings $ğ‘$ and $ğ‘$ equal. Note that empty strings are also equal.

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤100)$. Then $ğ‘¡$ test cases follow.

The first line of each test case contains the string $ğ‘$ $(1â‰¤\|ğ‘\|â‰¤20)$, consisting of lowercase Latin letters.

The second line of each test case contains the string $ğ‘$ $(1â‰¤\|ğ‘\|â‰¤20)$, consisting of lowercase Latin letters.

### Output
For each test case, output the minimum number of operations that can make the strings $ğ‘$ and $ğ‘$ equal.

## í’€ì´


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    string a; cin >> a;
    string b; cin >> b;
    int mx = 0;
    int aSize = (int) a.size();
    int bSize = (int) b.size();
    for (int i = 0; i < aSize; i++) {
        for (int j = 0; j < bSize; j++) {
            if (a[i] == b[j]) {
                int temp = 1;
                for (int k = j + 1; k < bSize; k++) {
                    if (a[i + k - j] == b[k]) temp++;
                    else break;
                }
                mx = max(mx, temp);
            }
        }
    }
    int ans = aSize + bSize - mx - mx;
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

# D. Epic Transformation

You are given an array $ğ‘$ of length $ğ‘›$ consisting of integers. You can apply the following operation, consisting of several steps, on the array $ğ‘$ zero or more times:

* you select two different numbers in the array $ğ‘_ğ‘–$ and $ğ‘_ğ‘—$;
* you remove $ğ‘–$-th and $ğ‘—$-th elements from the array. 

For example, if $ğ‘›=6$ and $ğ‘=[1,6,1,1,4,4]$, then you can perform the following sequence of operations:

* select $ğ‘–=1,ğ‘—=5$. The array $ğ‘$ becomes equal to $[6,1,1,4]$;
* select $ğ‘–=1,ğ‘—=2$. The array $ğ‘$ becomes equal to $[1,4]$. 

What can be the minimum size of the array after applying some sequence of operations to it?

### Input
The first line contains a single integer $ğ‘¡$ $(1â‰¤ğ‘¡â‰¤10^4)$. Then $ğ‘¡$ test cases follow.

The first line of each test case contains a single integer $ğ‘›$ $(1â‰¤ğ‘›â‰¤2â‹…10^5)$ is length of the array $ğ‘$.

The second line of each test case contains $ğ‘›$ integers $ğ‘_1,ğ‘_2,â€¦,ğ‘_ğ‘›$ ($1â‰¤ğ‘_ğ‘–â‰¤10^9)$.

It is guaranteed that the sum of $ğ‘›$ over all test cases does not exceed $2â‹…10^5$.

### Output
For each test case, output the minimum possible size of the array after applying some sequence of operations to it.

## í’€ì´ 1


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    int n; cin >> n;
    map<int, int> mp;
    for (int i = 0; i < n; i++) {
        int a; cin >> a;
        mp[a]++;
    }
    vector<pair<int, int> > vp;
    for (auto iter = mp.begin(); iter != mp.end(); iter++) {
        vp.emplace_back(iter->second, iter->first);
    }
    sort(vp.begin(), vp.end(), greater<>());
    vector<int> v;
    for (int i = 0; i < (int) vp.size(); i++) {
        for (int j = 0; j < vp[i].first; j++) {
            v.push_back(vp[i].second);
        }
    }
    vector<int> ans(n + 1);
    int temp = 0;
    for (int i = 1; i <= n; i += 2) ans[i] = v[temp++];
    for (int i = 2; i <= n; i += 2) ans[i] = v[temp++];
    int res = 0;
    for (int i = 1; i < n; i += 2) {
        if (ans[i] == ans[i + 1]) res += 2;
    }
    if (n % 2 != 0) res++;
    cout << res << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```

## í’€ì´ 2


### ì½”ë“œ
```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

void solve() {
    int n; cin >> n;
    map<int, int> mp;
    for (int i = 0; i < n; i++) {
        int a; cin >> a; mp[a]++;
    }
    int mx = 0;
    for(auto& iter : mp) mx = max(mx, iter.second);
    cout << max(n % 2, mx - (n - mx)) << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while(t--) solve();
    return 0;
}

```
<https://codeforces.com/contest/1506>{:target="_blank"}
